<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原生JavaScript获取Dom元素的位置信息]]></title>
    <url>%2F2019%2F04%2F21%2FDomPosition%2F</url>
    <content type="text"><![CDATA[网页的大小 document元素的clientHeight和clientWidth属性，就代表了网页的大小。clientHeight和clientWidth指元素的内容部分再加上padding的所占据的视觉面积，不包括border和滚动条占用的空间。1234567891011121314// 获取浏览器窗口的大小 function getViewport()&#123; if (document.compatMode == "BackCompat")&#123; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125; &#125; else &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125; &#125; &#125; document.compatMode用来判断浏览器是否是标准的兼容模式这个函数必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错 获取网页大小的另外一种方法网页上的每个元素还有scrollHeight和scrollWidth属性，指包含滚动条在内的该元素的视觉面积。1234567891011121314// 类似于上面的getViewport方法 function getPagearea()&#123; if (document.compatMode == "BackCompat")&#123; return &#123; width: document.body.scrollWidth, height: document.body.scrollHeight &#125; &#125; else &#123; return &#123; width: document.documentElement.scrollWidth, height: document.documentElement.scrollHeight &#125; &#125; &#125; 如果网页内容能够在浏览器窗口中全部显示，不出现滚动条，那么网页的clientWidth和scrollWidth应该相等。但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值 获取网页中某个元素的绝对位置每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器（offsetParent对象）左上角的距离。123456789101112131415161718192021222324// 获取绝对位置的横坐标和纵坐标。 function getElementLeft(element)&#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft; &#125; function getElementTop(element)&#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null)&#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop; &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[:checked伪类选择器的妙用 -- 立体切换按钮]]></title>
    <url>%2F2019%2F04%2F16%2Fcss-checked%2F</url>
    <content type="text"><![CDATA[效果预览 查看效果 :checked是什么？ :checked CSS 伪类选择器表示任何处于选中状态的radio(), checkbox () 或(“select”) 元素中的option HTML元素(“option”)。12345/* 匹配任意被勾选/选中的radio(单选按钮),checkbox(复选框),或者option(select中的一项) */:checked &#123; margin-left: 25px; border: 1px solid blue; &#125; 用户通过勾选/选中元素或取消勾选/取消选中，来改变该元素的 :checked 状态。 源代码 HTML结构123456&lt;input type="checkbox" class="toggle"&gt;&lt;div class="switch"&gt; &lt;div class="inner"&gt; &lt;div class="disc"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495body &#123; margin: 0; height: 100vh; display: flex; align-items: center; justify-content: center; background-color: #90bc90;&#125; :root &#123; --font-size: 20px;&#125;/* 选择框 *//* 其中 filter: opacity(0); 相当于 opacity: 0; */.toggle &#123; position: absolute; width: 10em; height: 5em; font-size: var(--font-size); margin: 0; filter: opacity(0); cursor: pointer; z-index: 2;&#125;/* 外侧椭圆 */.toggle~.switch &#123; position: absolute; width: 10em; height: 5em; font-size: var(--font-size); background: linear-gradient(silver, whitesmoke); border-radius: 2.5em; display: flex; align-items: center; justify-content: center;&#125;/* 内侧椭圆 */.toggle~.switch .inner &#123; width: 8em; height: 3.5em; background: linear-gradient(dimgray, silver); border-radius: 2em; box-shadow: inset 0 0 1.5em rgba(0, 0, 0, 0.5); display: flex; justify-content: center;&#125;/* 圆形按钮 */.toggle~.switch .inner .disc &#123; width: 3.5em; height: 3.5em; background: linear-gradient(to top, silver, whitesmoke); border-radius: 50%; box-shadow: 0 0.4em 0.6em rgba(0, 0, 0, 0.2); position: relative; left: -30%; display: flex; align-items: center; justify-content: center; transition: 0.5s;&#125;/* 通过伪元素来为按钮增加立体效果 */.toggle~.switch .inner .disc::before &#123; content: 'OFF'; position: absolute; width: 80%; height: 80%; background: linear-gradient(silver, whitesmoke); border-radius: 50%; text-align: center; line-height: calc(3.5em * 0.8); font-family: sans-serif; color: gray;&#125;/* 通过单选框input的伪类选择器来控制内侧椭圆的背景颜色的切换 */.toggle:checked~.switch .inner &#123; background: linear-gradient(green, limegreen);&#125;/* 通过单选框input的伪类选择器来控制按钮的左右切换 */.toggle:checked~.switch .inner .disc &#123; left: 30%;&#125;/* 通过单选框input的伪类选择器来控制按钮的文本内容 */.toggle:checked~.switch .inner .disc::before &#123; content: 'ON'; color: limegreen;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5中的sessionStorage和Localstorage中的storage事件]]></title>
    <url>%2F2019%2F04%2F13%2FstorageEvent%2F</url>
    <content type="text"><![CDATA[storage事件当储存的数据发生变化时，会触发storage事件。123window.addEventListener("storage", event =&gt; &#123; console.log(event)&#125;) 回调函数接受一个event对象作为参数，该参数含有四个属性： oldValue：更新前的值。如果该键为新增加，则这个属性为null。 newValue：更新后的值。如果该键被删除，则这个属性为null。 url：原始触发storage事件的那个网页的网址。 key: 发生变化的属性的key值 值得特别注意的是，该事件不在导致数据变化的当前页面触发。如果浏览器同时打开一个域名下面的多个页面，当其中的一个页面改变sessionStorage或localStorage的数据时，其他所有页面的storage事件会被触发，而原始页面并不触发storage事件。可以通过这种机制，实现多个窗口之间的通信。IE浏览器除外，它会在所有页面触发storage事件。 代码：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;sessionStorage-localStorage 的storage事件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" placeholder="输入"&gt; &lt;button&gt;点我&lt;/button&gt; &lt;script&gt; (function(D) &#123; var val = D.getElementsByTagName("input")[0], btn = D.getElementsByTagName("button")[0]; btn.onclick = function() &#123; var value = val.value; if(!value) return; localStorage.setItem("key", val.value); &#125;; window.addEventListener("storage", function(e) &#123; console.log("e"); console.log(e); &#125;); &#125;)(document); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>LocalStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识node]]></title>
    <url>%2F2019%2F04%2F10%2Fnode%2F</url>
    <content type="text"><![CDATA[什么是Chrome V8引擎？ V8 是 Google 发布的开源 JavaScript 引擎，采用 C++ 编写，在 Google 的 Chrome 浏览器中被使用。V8 引擎可以独立运行，也可以用来嵌入到 C++ 应用程序中执行。 module（模块） 在 Node.js 模块系统中，每个文件都被视为一个独立的模块。 例如，假设有一个名为 foo.js 的文件： 123// foo.jsconst circle = require('./circle.js');console.log(`半径为4的圆的面积为$&#123;circle.area(4)&#125;`); 在第一行中， foo.js 加载了与 foo.js 在同一目录中的 circle.js 模块以下是 circle.js 的内容： 123// circle.jsconst &#123; PI &#125; = Mathexport.area = r =&gt; PI * r**2 circle.js 模块导出了 area() 函数。 通过在特殊的 exports 对象上指定额外的属性，可以将函数和对象添加到模块的根部。 events（事件触发器） 大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。 所有能触发事件的对象都是 EventEmitter 类的实例。 这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上。 事件的命名通常是驼峰式的字符串。 当 EventEmitter 对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用。 例子，一个简单的 EventEmitter 实例，绑定了一个监听器。 eventEmitter.on() 用于注册监听器， eventEmitter.emit() 用于触发事件。12345678910111213141516171819const event = require('events')class MyEmitter extends EventEmitter &#123;&#125;const myEmiiter = new MyEmitter()myEmiiter.on('EventName', msg =&gt; &#123; // console.log(msg) setImmediate(() =&gt; &#123; console.log(msg) &#125;)&#125;)myEmiiter.emit('someEvent', '触发事件')console.log(1)// 1// 触发事件// 由于异步的原因，先输出 1 然后再输出 “触发事件” fs（文件系统） 所有文件系统操作都具有同步和异步的形式。 文件读取同步读取1234const fs = require('fs')const readme = fs.readFileSync('readMe.txt', 'utf-8')console.log(readme) 异步读取1234567const fs = require('fs')fs.readFile('readMe.txt', 'utf8', (err, data) =&gt; &#123; if (err) throw err // 异步读取的同时，将读取到的内容写入temp.txt文件中 fs.writeFileSync('temp.txt', data)&#125;) 文件写入123const fs = require('fs')fs.writeFileSync('readme.txt', 'hello world') 文件删除123456const fs = require('fs')fs.unlink('readMe.txt', (err) =&gt; &#123; if (err) throw err; console.log('已成功删除 readMe.txt');&#125;); 创建文件夹1234567891011121314const fs = require('fs')fs.mkdir('utils', (err) =&gt; &#123; if (err) throw err // 先读取已有文件中的内容 fs.readFile('readme.txt', 'utf8', (err, data) =&gt; &#123; if (err) throw err; // 在新建的文件夹中新建content.txt文件，将读取的内容写入其中 fs.writeFile('./utils/content.txt', data, err =&gt; &#123; if (err) throw err; console.log('文件添加成功') &#125;) &#125;)&#125;) http(HTTP)Buffer在引入 TypedArray之前，JavaScript 语言没有用于读取或操作二进制数据流的机制。 Buffer 类是作为 Node.js API 的一部分引入的，用于在 TCP 流、文件系统操作、以及其他上下文中与八位字节流进行交互。 Stream流（stream）是 Node.js 中处理流式数据的抽象接口。 stream 模块用于构建实现了流接口的对象。 http 搭建简单的服务123456789101112const http = require('http')const server = http.createServer((req, res) =&gt; &#123; // console.log('客户端向服务端请求' + req.url) res.writeHead(200, 'Content-type: "text/plain') res.end("server is running...")&#125;)// 服务监听的端口和ip地址server.listen(8888, "127.0.0.1")console.log('server is running') 读写数据流1234567891011121314const fs = require('fs')const myReadStream = fs.createReadStream(__dirname + '/readme.txt', 'utf8')// 写入const myWriteStream = fs.createWriteStream(__dirname + '/writeme2.txt')myReadStream.pipe(myWriteStream)console.log(myReadStream)myReadStream.on('data', chunk =&gt; &#123; console.log('=============接受部分数据==========') myWriteStream.write(chunk)&#125;)]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo写博客 -- MarkDown语法]]></title>
    <url>%2F2019%2F04%2F10%2Fhexo-markdown%2F</url>
    <content type="text"><![CDATA[本文主要介绍其在写博客中的一些特点： 自动生成目录 代码块高亮 引用展示 表格插入 图片插入 强调显示 列表显示 自动URL链接 主要语法简述： 分段： 两个回车 换行： 两个空行 + 回车 标题： # ~ #######，#号的个数表示几级标题 强调： **文字** __文字__ _文字_ *文字* 引用： &gt; 后面紧跟个空格 表格： - 和 | 分割行和列， :控制对齐方式 代码块： 四个空格开头或者使用 ``` 代码内容 ``` 链接： [文字](链接地址) 图片： ![图片说明](图片地址)，地址可以是本地地址，也可以是网络地址 列表： *， +， -， 1.，选择其中一个，注意后面加空格 标题1234567# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt;####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行） 内容强调（加粗、斜体）123字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示 效果：字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示s 1234字体 __加粗__ 显示字体 _斜体_ 显示字体 ___加粗并斜体___ 显示组合 *__加粗并斜体__* 显示 效果：字体 加粗 显示字体 _斜体_ 显示字体 加粗并斜体 显示组合 加粗并斜体 显示 删除线1这样来 ~~删除一段文本~~ 这样来 删除一段文本 高亮12使用&lt;code&gt;\`&lt;/code&gt;来强调字符 //想打出 ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调比如`突出背景色`来显示强调效果 使用`来强调字符比如突出背景色来显示强调效果 引用显示引用过程中任然支持Markdown语法！ 标准使用12345678&gt; 每行开始都使用 '&gt;'；&gt; 引用**开始**；&gt; 引用**换行**；&gt; 引用**结束**。&gt; 还在引用中！两个回车结束引用！ 每行开始都使用 ‘&gt;’；引用开始；引用换行；引用结束。 还在引用中！ 两个回车结束引用！ 省略使用123456&gt; 仅第一行加应用；引用**开始**；引用**换行**；引用**结束**；两个回车结束引用,不在引用范围内了！ 仅第一行加应用；引用开始；引用换行；引用结束； 两个回车结束引用,不在引用范围内了 嵌套使用123456789101112131415&gt; 动物&gt;&gt; 水生动物&gt;&gt; 陆生动物&gt;&gt;&gt; 猴子&gt;&gt;&gt; 人&gt;&gt;&gt;&gt; 程序猿&gt;&gt;&gt;&gt; 攻城狮&gt;&gt;产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记&gt;&gt; 两栖类动物&gt;&gt;&gt; 大鳄鱼唐老鸭两个回车结束引用,不在引用范围内了！ 效果： 动物 水生动物陆生动物 猴子人 程序猿攻城狮产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记 两栖类动物 大鳄鱼唐老鸭 两个回车结束引用,不在引用范围内了！ 表格12345列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 可以用冒号来定义对齐方式 1234| 左对齐 | 右对齐 | 居中 || :-------- | -------:| :--: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 | 效果：| 左对齐 | 右对齐 | 居中 || :——– | ——-:| :–: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 | 代码块代码块语法遵循标准 markdown 代码，使用 ``` 开始 ， ``` 结束 例如：1234567```JavaScriptclass Person &#123; sayHello() &#123; return 'Hello World' &#125;&#125;```\ 效果：12345class Person &#123; sayHello() &#123; return 'Hello World' &#125;&#125; 链接插入12[首页](http://www.changxin00.cn/)[我的信息](http://www.97guitao.cn) 效果：首页我的信息 图片插入12![我的头像](http://zhuzhuyule.xyz/images/avatar.png)![我的头像](/images/avatar.png) 效果：我的头像我的头像]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
